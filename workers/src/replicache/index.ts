import { ReadonlyJSONValue, WriteTransaction } from 'replicache';
import { z } from 'zod';

import { ListElementUnion } from '../list';

export const MutationSchema = z.object({
	clientID: z.string(),
	id: z.number(),
	name: z.string(),
	args: z.any(),
});

export const PushRequestSchema = z.object({
	profileID: z.string(),
	clientGroupID: z.string(),
	mutations: z.array(MutationSchema),
});

// ReplicacheClient represents an instance of the Replicache JS class
// that has synced with the server.
export type ReplicacheClient = {
	// Globally unique ID, generated by Replicache.
	id: string;

	// Last mutation the server has processed from this client.
	// Corresponds to the list's `version`?
	lastMutationID: number;

	// The Version of the top-level List that this Client had a hand
	// in updating. We use this value when responding to a Pull Request
	// because it allows us to know whether this Client has been synced
	// with the frontend.
	lastModifiedVersion: number;
};

export const CLIENT_GROUP_KEY_PREFIX = `client_group/`;
export const clientGroupKey = (id: string) => {
	if (!id) throw new Error('invalid id');
	return `${CLIENT_GROUP_KEY_PREFIX}${id}`;
};

// ReplicacheClientGroup represents a group of related ReplicacheClients.
// Typically, there is one per browser profile.
export type ReplicacheClientGroup = {
	clients: Map<string, ReplicacheClient>;

	// Globally unique ID, generated by Replicache.
	id: string;

	// The user ID that created this ReplicacheClientGroup.
	// Optional, but required if the application is authenticated.
	userId?: any;
};

// Pick the methods and properties from Replicache's `WriteTransaction`
// so we can share mutators. Exclude `scan` because I don't know how to
// implement it to satisfy Replicache's requirements.
export type SimpleWriteTransaction = Pick<
	WriteTransaction,
	'reason' | 'set' | 'del' | 'location' | 'get' | 'isEmpty'
>;

/**
 * Implements *most* of Replicache's WriteTransaction interface with
 * methods of Cloudflare's Durable Object Transactional Storage.
 *
 * Allows us to share mutators between front- and back-ends.
 *
 * @see https://developers.cloudflare.com/durable-objects/api/transactional-storage-api
 * @see https://github.com/rocicorp/replicache-transaction/blob/main/src/replicache-transaction.ts
 */
export class TransactionalStorageToRepTx implements SimpleWriteTransaction {
	// clientID: string;
	// mutationID = 0;

	// private _storage: DurableObjectStorage;
	#nextVersion: number; // figure out how to set this
	#transaction: DurableObjectTransaction;

	readonly environment = 'server';
	readonly location = 'server';
	readonly reason = 'authoritative';

	constructor(transaction: DurableObjectTransaction, nextVersion: number) {
		this.#transaction = transaction;
		this.#nextVersion = nextVersion;
	}

	del(key: string): Promise<boolean> {
		return this.#transaction.delete(key);
	}

	get(key: string): Promise<ReadonlyJSONValue | undefined> {
		return this.#transaction.get(key);
	}

	has(key: string): Promise<boolean> {
		return this.get(key).then((val) => val !== undefined);
	}

	/** Whether the database is empty. */
	isEmpty(): Promise<boolean> {
		return this.#transaction.list({ limit: 1 }).then((val) => val.size === 0);
	}

	set(key: string, value: ReadonlyJSONValue): Promise<void> {
		let tempValue = value;

		const parseResult = ListElementUnion.safeParse(value);

		// If `value` a `ListElement`, then we update the `version`
		// property to the `nextVersion` so everything stays in sync.
		if (parseResult.success) {
			tempValue = { ...parseResult.data, version: this.#nextVersion };
		}

		return this.#transaction.put(key, tempValue);
	}
}
